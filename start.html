<!DOCTYPE html>
<html lang="en">
<head>
    <title>DeepChart | Machine Learning algorithm for chart classification</title>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="https://i.ibb.co/SrkP1nP/favicon.png">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <!-- FontAwesome JS -->
    <script defer src="https://use.fontawesome.com/releases/v5.8.2/js/all.js" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" crossorigin="anonymous"></script>
    <!-- Global CSS -->
    <link rel="stylesheet" href="assets/plugins/bootstrap/css/bootstrap.min.css">
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="assets/plugins/prism/prism.css">
    <link rel="stylesheet" href="assets/plugins/elegant_font/css/style.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css">

</head>

<body class="body-green">
    <div class="page-wrapper">
        <!-- ******Header****** -->
        <header id="header" class="header">
            <div class="container">
                <div class="branding">
                    <h1 class="logo">
                        <a href="index.html">
                            <span aria-hidden="true" class="icon_documents_alt icon"></span>
                            <span class="text-highlight">Deep</span><span class="text-bold">Chart</span>
                        </a>
                    </h1>

                </div><!--//branding-->
          </div><!--//container-->
        </header><!--//header-->
        <div class="doc-wrapper">
            <div class="container">
                <div id="doc-header" class="doc-header text-center">
                    <h1 class="doc-title"><i class="icon fa fa-paper-plane"></i> Quick Start</h1>
                </div><!--//doc-header-->
                <div class="doc-body row">
                    <div class="doc-content col-md-9 col-12 order-1">
                        <div class="content-inner">
                            <section id="download-section" class="doc-section">
                              <h2 class="code-line" data-line-start=2 data-line-end=3 ><a id="Le_projet_2"></a>Le projet</h2>
    <p class="has-line-data" data-line-start="4" data-line-end="5">Ce répertoire permet à partir d’une base de données d’images contenant n classes différentes d’entraîner un modèle de réseaux de neurones convolutionnels et de le tester sur une base test.</p>
    <p class="has-line-data" data-line-start="6" data-line-end="7">À partir d’une base de données contenant n classes d’images de tailles et de formats quelconques, on redimensionne chaque image à la taille size x size et on convertit en JPG. Il est primordial que le nom de la classe de l’image soit dans son nom, et notre script pour scrapper Google Image le fait automatiquement, en renommant avec la requête réalisée.</p>
    <p class="has-line-data" data-line-start="8" data-line-end="9">On crée deux dossiers :</p>
    <ul>
    <li class="has-line-data" data-line-start="9" data-line-end="10">/data contient x% des images pour entraîner le réseau de neurones convolutionnels</li>
    <li class="has-line-data" data-line-start="10" data-line-end="12">/test contient (1-x)% des images pour tester le modèle finale enregistré</li>
    </ul>
    <p class="has-line-data" data-line-start="12" data-line-end="14">À partir du dossier /data, on sérialise nos images de ‘train’ &amp; ‘validation’ ainsi que leur labels respectifs dans un fichier pkl. Celui-ci sera lu pour entraîner le réseau de neurones.<br>
    À la fin de l’entraînement, qui peut être plus ou moins long suivant les paramètres que vous avez choisis, le modèle est enregistré.</p>
    <p class="has-line-data" data-line-start="15" data-line-end="16">Il est ensuite utilisé automatiquement sur le dossier /test créé ultérieurement et en ressort une matrice de confusion.</p>
    <p class="has-line-data" data-line-start="17" data-line-end="18">Comme chaque variable intermédiaire est enregistrée (modèle CNN entraînée, dataset dans le fichier pkl, dossiers /data et /test) il est possible de les réutiliser sans réaliser toutes les étapes.</p>
    <p class="has-line-data" data-line-start="19" data-line-end="20">Dans le fichier settings.py il vous est possible de modifier les différents paramètres clés utilisés dans nos scripts Python, comme la taille des images, le part de l’ensemble test, etc.</p>
    <p class="has-line-data" data-line-start="21" data-line-end="22">Si vous souhaitez comprendre plus en détail le déroulement, les méthodes ainsi que les rendus du projet, le rapport et les présentations de projets sont disponibles dans le dossier document .</p>
    <h1 class="code-line" data-line-start=23 data-line-end=24 ><a id="Prise_en_main_23"></a>Prise en main</h1>
    <h2 class="code-line" data-line-start=25 data-line-end=26 ><a id="Lancement_25"></a>Lancement</h2>
    <p class="has-line-data" data-line-start="27" data-line-end="28">Afin d’installer l’ensemble des packages nécessaires au fonctionnement du script, installer le module pip et exécuter la commande suivante :</p>
    <pre><code class="has-line-data" data-line-start="30" data-line-end="32">pip3 install -r requirements.txt
    </code></pre>
    <p class="has-line-data" data-line-start="33" data-line-end="35">Dans le terminal, placez vous dans le dossier que vous venez de clôner.<br>
    Pour lancer le script, tapez :</p>
    <pre><code class="has-line-data" data-line-start="36" data-line-end="38">python3 main.py
    </code></pre>
    <p class="has-line-data" data-line-start="38" data-line-end="39">Après l’exécution du script, un fichier “results_&lt;date_de_creation&gt;.json” est créé. Celui-ci contient la date d’exécution, les paramètres utilisés ainsi, les différentes probabilités de label pour chaque image et des métriques sur chaque classe (précision et recall).</p>
    <p class="has-line-data" data-line-start="40" data-line-end="41">Ce fichier sera utilisé pour la visualisation des résultats à l’aide du framework d3.js.</p>
    <h2 class="code-line" data-line-start=42 data-line-end=43 ><a id="Scrapping_42"></a>Scrapping</h2>
    <p class="has-line-data" data-line-start="44" data-line-end="45">Nous utiliserons le script google-scrapper_2.0.py issu du git image-scrapers afin de peupler notre base de données. Celui-ci permet de récupérer des images issues de google et fournit un JSON associé.</p>
    <p class="has-line-data" data-line-start="46" data-line-end="47">Afin d’installer l’ensemble des packages nécessaires au fonctionnement du script, installer le module pip et exécuter la commande suivante :</p>
    <pre><code class="has-line-data" data-line-start="49" data-line-end="51">pip3 install -r requirements-scraper.txt
    </code></pre>
    <p class="has-line-data" data-line-start="52" data-line-end="53">Afin d’utiliser le script de scrapping, il faut:</p>
    <ul>
    <li class="has-line-data" data-line-start="53" data-line-end="54">installer le driver chrome correpondant à la version du navigateur GoogleChrome présente sur l’ordi </li>
    <li class="has-line-data" data-line-start="54" data-line-end="56">modifier la ligne 24 du script et renseigner l’emplacement du driver</li>
    </ul>
    <pre><code class="has-line-data" data-line-start="57" data-line-end="59">browser = webdriver.Chrome(executable_path=r'C:/Users/Desktop/chromedriver.exe')
    </code></pre>
    <p class="has-line-data" data-line-start="60" data-line-end="61">Après modification du script, il faut remplacer les espaces de la requêtes par des “_”, par exemple pour scrapper les images de “bar chart”, on lancera la commande suivante:</p>
    <pre><code class="has-line-data" data-line-start="63" data-line-end="65">python3 google-scrapper_2.0 bar_chart
    </code></pre>
    <p class="has-line-data" data-line-start="66" data-line-end="67">Ce script nous permet de récupérer plusieurs centaines d’images exploitables par classe et d’avoir des images correctement nommées pour faire tourner nos algorithmes.</p>
    <h2 class="code-line" data-line-start=68 data-line-end=69 ><a id="Traitement_dimage_68"></a>Traitement d’image</h2>
    <p class="has-line-data" data-line-start="70" data-line-end="71">Le fichier loadData.py permet d’effectuer un traitement préliminaire sur la base de données. Il contient la fonction “resize_dataset” qui prend en entrée trois arguments :</p>
    <ul>
    <li class="has-line-data" data-line-start="71" data-line-end="72">La dossier contenant l’ensemble de la base de données, la taille d’image désirée ainsi que la largeur</li>
    <li class="has-line-data" data-line-start="72" data-line-end="73">Il charge chaque image de la base de données et compare son ratio au ratio désiré : si le ratio ne convient pas, on ajoute du blanc à droite ou en bas de l’image afin de ne pas déformer l’image originale lors du changement d’échelle</li>
    <li class="has-line-data" data-line-start="73" data-line-end="74">On effectue le changement d’échelle de l’image pour obtenir les dimensions voulues</li>
    <li class="has-line-data" data-line-start="74" data-line-end="76">L’image est enregistrée au format “.jpg” dans le dossier data</li>
    </ul>
    <p class="has-line-data" data-line-start="76" data-line-end="77">Cela nous permet d’avoir un ensemble d’images au bon format en entrée de notre réseau de neurones.</p>
    <h2 class="code-line" data-line-start=78 data-line-end=79 ><a id="Paramtres_de_contrle_du_fichier_settingspy_78"></a>Paramètres de contrôle du fichier settings.py</h2>
    <p class="has-line-data" data-line-start="80" data-line-end="81">Avant de lancetr le script, il est nécessaire de choisir les paramètres voulus dans le fichier settings.py.</p>
    <p class="has-line-data" data-line-start="82" data-line-end="83">Voici en détail les rôle de chaque paramètre :</p>
    <ul>
    <li class="has-line-data" data-line-start="83" data-line-end="84">databasePath : emplacement du fichier d’images sources</li>
    <li class="has-line-data" data-line-start="84" data-line-end="85">size : choix de la résolution de l’image (Attention, au delà de 64x64, cela devient très couteux pour les machines habituelles)</li>
    <li class="has-line-data" data-line-start="85" data-line-end="86">offset_test : pourcentage d’image prise pour tester le modèle (Par défaut à 0.1)</li>
    <li class="has-line-data" data-line-start="86" data-line-end="87">offset_train_val : pourcentage d’image du dossier d’entraînement, prise pour l’apprentissage. Le reste sert à la validation (Par défaut à 0.8)</li>
    <li class="has-line-data" data-line-start="87" data-line-end="88">nb_epoch nombre d’itérations, ie nombre de fois que chaque image va passer dans le réseau</li>
    <li class="has-line-data" data-line-start="88" data-line-end="89">batch_size : nombre d’images qui passent en même temps dans le réseau</li>
    <li class="has-line-data" data-line-start="89" data-line-end="90">learning_rate : taux d’apprentissage. Par défaut, fixé à 0.001</li>
    <li class="has-line-data" data-line-start="90" data-line-end="91">strictness_class : ce paramètre permet de classifier plus sérieusement. En effet, le réseau n’attribuera une image à une classe qu’uniquement si son score est supérieur à ce chiffre * score du hasard (i.e. supérieur à strictness_class * 1/classes_number). Si le score est trop faible, l’image sera associée à la catégorie “uncategorizd”. Bien entendu, si ce paramètre est fixé à 1, cela correspond au cas classique.</li>
    <li class="has-line-data" data-line-start="91" data-line-end="92">nb_filter : nombre de filtres pour le réseau 1 dans la couche initiale (attention, ne fonctionne que si le réseau 1 est choisi. Pour les autres réseaux, ce paramètre est fixé à 32)</li>
    <li class="has-line-data" data-line-start="92" data-line-end="93">filter_size : taille / résolution du filtre</li>
    <li class="has-line-data" data-line-start="93" data-line-end="94">reseau : choix du réseau. Allant de 1 à 5, les structures des réseaux sont disponibles dans le fichier reseau.py</li>
    </ul>
    <h2 class="code-line" data-line-start=96 data-line-end=97 ><a id="Comment_utiliser_nos_scripts__96"></a>Comment utiliser nos scripts ?</h2>
    <p class="has-line-data" data-line-start="98" data-line-end="99">Le fichier &lt; main.py &gt; permet de lancer les scripts :</p>
    <ul>
    <li class="has-line-data" data-line-start="99" data-line-end="100">loadData.py traite les images brutes et les redimensionnent à la taille voulue en JPG.</li>
    <li class="has-line-data" data-line-start="100" data-line-end="101">build_dataset.py sérialise les images de train-validation et leurs labels correspondant dans un fichier Pickle.</li>
    <li class="has-line-data" data-line-start="101" data-line-end="102">reseau.py définit les différents modèles de réseaux de neurones que l’on peut choisir dans le fichier settings.py</li>
    <li class="has-line-data" data-line-start="102" data-line-end="103">neuralnetwork.py permet d’entraîner le modèle choisit à partir des données issues du fichier pkl et enregistre le modèle entraîné.</li>
    <li class="has-line-data" data-line-start="103" data-line-end="104">prediction.py utilise le modèle entraîné sur un ensemble test créé au préalable et enregistre les métriques dans un fichier JSON.</li>
    <li class="has-line-data" data-line-start="104" data-line-end="106">result.py permet d’initialiser la structure de notre fichier JSON, avec notamment tous les paramètres choisis pour le lancement des scripts.</li>
    </ul>
    <h2 class="code-line" data-line-start=106 data-line-end=107 ><a id="Utilisation_de_lAPI_106"></a>Utilisation de l’API</h2>
    <p class="has-line-data" data-line-start="108" data-line-end="109">L’utilisation de l’API est décrite sur le repository DatasetVisApi</p>
    <p class="has-line-data" data-line-start="110" data-line-end="111">Le site permettra alors de visualiser les prédictions suivants notre réseau de neurone sous la forme d’un graphe radar.</p>
    <h1 class="code-line" data-line-start=113 data-line-end=114 ><a id="Pour_une_meilleure_comprhension_113"></a>Pour une meilleure compréhension</h1>
    <h2 class="code-line" data-line-start=115 data-line-end=116 ><a id="Construction_de_la_base_de_donnes_115"></a>Construction de la base de données</h2>
    <h3 class="code-line" data-line-start=117 data-line-end=118 ><a id="Scrapping_117"></a>Scrapping</h3>
    <p class="has-line-data" data-line-start="119" data-line-end="120">La première partie de notre travail consiste en la collecte de visualisations de données, par exemple des nuages de points ou des histogrammes, afin de constituer une base de données d’images suffisamment grande pour entraîner un modèle de réseaux de neurones convolutionnels et le tester.</p>
    <p class="has-line-data" data-line-start="121" data-line-end="123">Grâce au script Python google-scrapper_2.0.py inspiré du git image-scrapers, il est possible de récupérer des centaines d’images issues d’une requête sur Google Image.<br>
    En effet, ce script permet de lancer un driver de Google Chrome, de réaliser la requête souhaitée sur Google Image et de scroller automatiquement jusqu’en bas de la page afin de charger toutes les images possibles pour pouvoir ensuite les télécharger avec un JSON associé, contenant la provenance de l’image notamment. Ceci nous permet de garder une trace des sources utilisées. Nous avons apporté des modifications au script initial afin de renommer automatiquement les images téléchargées avec leur classe et un identifiant unique.</p>
    <p class="has-line-data" data-line-start="125" data-line-end="126">Ainsi, si on souhaite récupérer des centaines d’images de “bar chart”, on exécute le script Python comme suit, en prenant soin d’ajouter les “_ ” à la place des espaces :</p>
    <pre><code class="has-line-data" data-line-start="128" data-line-end="130">python3 google-scrapper_2.0 bar_chart
    </code></pre>
    <p class="has-line-data" data-line-start="131" data-line-end="134">On obtient alors des centaines d’images nommées suivant l’exemple suivant<br>
    “bar_chat_1.jpg”. Ceci nous sera très utile pour associer à chaque image sa classe. Nous avons utilisé ce script pour collecter des images des dix classes sélectionnées. Les résultats se trouvent dans un dossier situé dans le répertoire du script scrapper, dont le nom est dataset. Chaque sous-dossier de dataset correspond au résultat d’une requête.<br>
    Sur le git de notre projet DatasetVis, il est possible de suivre un tutoriel pour pouvoir utiliser ce script de scrapping.</p>
    <p class="has-line-data" data-line-start="135" data-line-end="136">Il faut ensuite nettoyer ce premier jeu de données pour obtenir une base de données propre et exploitable.</p>
    <h3 class="code-line" data-line-start=138 data-line-end=139 ><a id="Nettoyage_du_jeu_de_donnes_138"></a>Nettoyage du jeu de données</h3>
    <p class="has-line-data" data-line-start="140" data-line-end="141">Une fois les images des dix classes téléchargées, il faut nettoyer ce jeu car il comporte des images illisibles, et des images qui ne correspondent pas à la requête réalisée, ou alors comportant trop de bruit. Voici les critères que nous avons utilisé pour exclure les images non conformes. Ils sont issus de l’expérience. Cette liste n’est pas exhaustive mais correspond aux cas qui reviennent le plus souvent.</p>
    <p class="has-line-data" data-line-start="142" data-line-end="143">Pour les dix catégories, les images que nous avons retirées, en plus de celles qui n’étaient pas lisibles, valident un ou plusieurs critères suivants :</p>
    <ul>
    <li class="has-line-data" data-line-start="144" data-line-end="145">Légende / bruit représentant une part trop importante de l’image</li>
    <li class="has-line-data" data-line-start="145" data-line-end="146">Graphique regroupant 2 catégories (ex : à la fois bar et line chart)</li>
    <li class="has-line-data" data-line-start="146" data-line-end="147">Graphique trop simpliste (type icône ou vecteur)</li>
    <li class="has-line-data" data-line-start="147" data-line-end="149">Graphique tracé manuellement</li>
    </ul>
    <p class="has-line-data" data-line-start="149" data-line-end="150">Nous avons volontairement laissé du bruit dans nos données, introduit par du texte par exemple, des fonds hétérogènes ou encore des graphiques en trois dimensions. On obtient après nettoyage manuel au moins 300 images exploitables par classe. Notre dossier contient finalement plus de 3500 images. Certaines classes regroupent plus de 500 photos, d’autres près de 400. Nous construisons alors un dossier comprenant un nombre semblable d’image pour chaque catégorie : trois catégories bien renseignées (1350 images), six catégories (2100 images) et 10 catégories (3200 images).</p>
    <p class="has-line-data" data-line-start="151" data-line-end="152">Il est nécessaire de noter que ce nombre reste faible pour obtenir de très bons résultats. En effet, si l’on prend l’exemple de la base de données MNIST faite pour essayer de classer les chiffres manuscrits, la base données comporte 70 000 images. On se rend bien compte qu’il est très compliqué de constituer une telle base de données dans le temps imparti, et avec les ressources à disposition. Les résultats obtenus seront donc à nuancer au regard de ce point.</p>
    <h3 class="code-line" data-line-start=153 data-line-end=154 ><a id="Prparation_des_donnes_pour_les_phases_dentranement_et_de_test_153"></a>Préparation des données pour les phases d’entraînement et de test</h3>
    <p class="has-line-data" data-line-start="155" data-line-end="156">Une fois la collecte réalisée et le jeu de données propre, l’étape suivante consiste à la préparation de nos images pour l’entraînement du réseau de neurones.</p>
    <p class="has-line-data" data-line-start="157" data-line-end="158">Dans un premier temps, il est nécessaire de redimensionner toutes les images au même format. Le fichier  loadData.py  le permet. Il suffit de modifier dans settings.py le chemin vers le dossier contenant les images, ainsi que la largeur et la hauteur souhaitées.</p>
    <p class="has-line-data" data-line-start="159" data-line-end="160">Le script contient la fonction “resize_dataset” qui prend en entrée ces trois arguments, puis procède comme suit :</p>
    <ul>
    <li class="has-line-data" data-line-start="161" data-line-end="162">Il charge chaque image de la base de données et compare son ratio au ratio désiré : si le ratio ne convient pas, on ajoute du blanc à droite ou en bas de l’image afin de ne pas déformer l’image originale lors du changement d’échelle</li>
    <li class="has-line-data" data-line-start="162" data-line-end="163">On effectue le changement d’échelle de l’image pour obtenir les dimensions voulues</li>
    <li class="has-line-data" data-line-start="163" data-line-end="164">L’image est enregistrée au format &quot;.jpg&quot; dans le dossier data</li>
    <li class="has-line-data" data-line-start="164" data-line-end="166">On obtient alors un nouveau dossier /data dans le même répertoire, il contient les images redimensionnées au format JPG.</li>
    </ul>
    <p class="has-line-data" data-line-start="166" data-line-end="167">Dans un second temps, il faut préparer le jeu de données pour l’entraînement et le test. Grâce au script build_dataset.py, on sépare l’ensemble d’images contenu dans le répertoire data en :</p>
    <ul>
    <li class="has-line-data" data-line-start="167" data-line-end="168">Un ensemble test qui sera utilisé plus tard pour tester le modèle et calculer des métriques, créé dans le répertoire /test.</li>
    <li class="has-line-data" data-line-start="168" data-line-end="170">Et un ensemble d’entraînement-validation qui va être sérialisé dans un fichier Pickle dataset.pkl</li>
    </ul>
    <p class="has-line-data" data-line-start="170" data-line-end="171">Le pourcentage est à modifier dans le fichier settings.py, il est de 10% par défaut pour l’ensemble test, donc 90% pour l’ensemble d’entrainement. Dans cet ensemble d’entrainement, une partie est allouée à l’apprentissage, l’autre à la validation.</p>
    <p class="has-line-data" data-line-start="172" data-line-end="173">Il est à noter que dans le dossier parent les images sont mélangées avant de procéder à la séparation et nous nous assurons que la quantité d’image pour chaque classe dans les deux dossiers créés reste proche afin d’éviter la surreprésentation d’une classe.</p>
    <p class="has-line-data" data-line-start="174" data-line-end="175">Le fichier Pickle en sortie du script contient :</p>
    <ul>
    <li class="has-line-data" data-line-start="176" data-line-end="177">Le tableau des images d’entraînement ainsi que le tableau des labels respectifs pour chaque image</li>
    <li class="has-line-data" data-line-start="177" data-line-end="179">Le tableau des images de validation croisée ainsi que le tableau des labels respectifs pour chaque image</li>
    </ul>
    <p class="has-line-data" data-line-start="179" data-line-end="180">Une image correspond à un tableau de pixels et son label respectif à un tableau de 0 contenant un seul 1 suivant l’indice correspondant à la classe de l’image. Par exemple, [0,0,1] si notre BDD contient 3 classes et que l’image de l’exemple appartient à la 3ème classe.</p>
    <p class="has-line-data" data-line-start="181" data-line-end="182">Ces quatre objets sont sérialisés pour pouvoir être lus en entrée du réseau de neurones. Il est possible de modifier le pourcentage pour chacun des deux ensembles d’images. Par défaut, 20 % des images sont pour la validation et 80% pour l’entraînement.</p>
    <h3 class="code-line" data-line-start=183 data-line-end=184 ><a id="Choix_des_catgories_de_visuels_de_datavisualisation_183"></a>Choix des catégories de visuels de datavisualisation</h3>
    <p class="has-line-data" data-line-start="185" data-line-end="186">Pour sélectionner les premières classes de datavizualisation, nous avons pris plusieurs critères en ligne de compte :</p>
    <ul>
    <li class="has-line-data" data-line-start="187" data-line-end="188">Des types de graphiques très fréquents en datavizualisation (i.e. éviter des graphiques théoriques rarement utilisés)</li>
    <li class="has-line-data" data-line-start="188" data-line-end="189">L’abondance des ressources disponibles dans le cadre du scrapping</li>
    <li class="has-line-data" data-line-start="189" data-line-end="190">La propreté des ressources disponibles dans le cadre du scrapping, c’est-à-dire le fait qu’un faible nombre d’images parasites (qui ne sont pas de la classe considérée) polluent la base de données et soient chronophages à supprimer à la main.</li>
    <li class="has-line-data" data-line-start="190" data-line-end="191">La différenciation entre les classes permettant dans un premier temps de ne pas introduire trop de confusion pour l’algorithme (un stacked chart ou un histogram seront difficilement différentiables d’un bar chart).</li>
    </ul>
    <p class="has-line-data" data-line-start="193" data-line-end="194">Sur cette base, nous avons choisi les trois catégories suivantes, comprenant le plus d’images pertinentes :</p>
    <ul>
    <li class="has-line-data" data-line-start="194" data-line-end="195">Aera chart (diagramme à aire)</li>
    <li class="has-line-data" data-line-start="195" data-line-end="196">Bar chart (diagramme à barre)</li>
    <li class="has-line-data" data-line-start="196" data-line-end="198">Pie chart (camembert)</li>
    </ul>
    <p class="has-line-data" data-line-start="198" data-line-end="199">Nous avons enfin augmenté le nombre de catégories choisies. Cette extension s’est faite en deux étapes sur les mêmes critères que la sélection des trois classes initiales :</p>
    <ul>
    <li class="has-line-data" data-line-start="199" data-line-end="200">D’abord, le passage de 3 classes à 6 classes. Ont été ajouté les classes suivantes : line chart, venn diagram, radar chart.</li>
    <li class="has-line-data" data-line-start="200" data-line-end="201">Ensuite le passage de 6 classes à 10 classes. Ont été ajouté les classes suivantes : dot map, choropleth map et bubble chart</li>
    </ul>
    <h2 class="code-line" data-line-start=203 data-line-end=204 ><a id="Choix_des_mtriques_de_sortie_203"></a>Choix des métriques de sortie</h2>
    <h4 class="code-line" data-line-start=205 data-line-end=206 ><a id="Valeurs_de_sortie_205"></a>Valeurs de sortie</h4>
    <p class="has-line-data" data-line-start="206" data-line-end="208">En sortie du réseau, nous obtenons un vecteur de probabilité d’appartenance à chaque classe. La probabilité la plus grande détermine la classe à laquelle est attribuée l’image.<br>
    Il faut alors analyser ces attributions.</p>
    <h4 class="code-line" data-line-start=209 data-line-end=210 ><a id="Matrice_de_confusion_209"></a>Matrice de confusion</h4>
    <p class="has-line-data" data-line-start="210" data-line-end="211">Cette matrice classe recoupent les prédictions avec les valeurs réelles. Sur la diagonale (True Positive) se situent les images bien classées. Cela permet d’avoir une vision de la précision du modèle.</p>
    <h4 class="code-line" data-line-start=212 data-line-end=213 ><a id="Accuracy_212"></a>Accuracy</h4>
    <p class="has-line-data" data-line-start="213" data-line-end="214">Cette valeur calcule le nombre de d’instances bien classées. Elle permet de se rendre compte de la validité du modèle. Elle est égale à la somme des valeurs sur la diagonale divisée par la somme de tous les éléments de la table.</p>
    <h4 class="code-line" data-line-start=215 data-line-end=216 ><a id="Recall_ou_rappel_215"></a>Recall ou rappel</h4>
    <p class="has-line-data" data-line-start="216" data-line-end="218">Cette valeur calcule pour chaque classe le nombre d’instances bien classées sur le nombre d’instances de la classe (True Positive / Total d’instances la classe). Cela permet de se rendre compte de la faculté du modèle à trouver ou non les éléments d’une classe.<br>
    Le rappel total d’un modèle et la somme des rappels de chaque classe divisée par le nombre de classes.</p>
    <h4 class="code-line" data-line-start=219 data-line-end=220 ><a id="Prcision_219"></a>Précision</h4>
    <p class="has-line-data" data-line-start="220" data-line-end="222">Cette valeur calcule pour chaque classe le nombre d’instances bien classées sur le nombre d’instances attribuées à cette classe (True Positive / Total des prédictions de cette classe). Cela permet de se rendre compte de la pertinence du modèle dans la classification, i.e. à chaque fois qu’il prédit une classe, quelle est la chance pour que cette prédiction soit bonne.<br>
    La précision totale d’un modèle et la somme des précisions de chaque classe divisée par le nombre de classes.</p>
    <h4 class="code-line" data-line-start=223 data-line-end=224 ><a id="Svrit_du_modle_strictness_class_223"></a>Sévérité du modèle (strictness class)</h4>
    <p class="has-line-data" data-line-start="224" data-line-end="225">Ce paramètre est un paramètre additionnel qui nous permet de classer mieux que le hasard. En effet, il n’attribue une instance à une classe que si cette dernière a une probabilité x fois supérieur au hasard (1/nombre de classes). Dans notre modèle nous avons pris 1,3. Ce choix est arbitraire mais marque la volonté de classer de plus sûrement que le hasard. Si tel n’est pas le cas, cette instance est attribuée à la classe ‘uncategorized’, qui regroupe toutes les instances pour lesquelles aucune classe ne se démarque.</p>
    <h2 class="code-line" data-line-start=227 data-line-end=228 ><a id="Construction_de_notre_modle_final_227"></a>Construction de notre modèle final</h2>
    <h3 class="code-line" data-line-start=229 data-line-end=230 ><a id="Choix_des_paramtres_229"></a>Choix des paramètres</h3>
    <h4 class="code-line" data-line-start=231 data-line-end=232 ><a id="Itrations_231"></a>Itérations</h4>
    <p class="has-line-data" data-line-start="233" data-line-end="234">Nous avons fixé le nombre d’itérations à 125 pour les différents réseaux. Nous pouvons justifier ce choix en visualisant l’évolution de la perte (loss) et de la précision (accuracy) lors de la phase d’apprentissage. Les courbes représentatives (visualisable dans le rapport) ont bien atteint leurs asymptotes. On peut donc se satisfaire de ce nombre.</p>
    <h4 class="code-line" data-line-start=235 data-line-end=236 ><a id="Taux_dapprentissage_235"></a>Taux d’apprentissage</h4>
    <p class="has-line-data" data-line-start="237" data-line-end="238">Le taux d’apprentissage permet de définir la vitesse de convergence du modèle. Il est essentiel qu’il soit adapté puisque sinon le modèle ne peut converger, ou converge vers un résultat non optimal.</p>
    <p class="has-line-data" data-line-start="239" data-line-end="240">De la même manière que pour le nombre d’itération, nous avons comparé différents taux. Pour un taux faible (0.0001), cela ne converge pas rapidement, pour un taux trop haut (0.01) cela ne converge pas.</p>
    <h4 class="code-line" data-line-start=241 data-line-end=242 ><a id="Taille_du_filtre_241"></a>Taille du filtre</h4>
    <p class="has-line-data" data-line-start="243" data-line-end="245">Le filtre permet de déterminer la taille de la tuile. Via un filtre de taille 1, le réseau traitera tous les pixels indépendamment les uns des autres.<br>
    A partir du réseau 1, nous avons comparé les résultats pour différentes tailles de filtre. Il faut noter que la puissance de nos machines ne nous permet pas d’utiliser des filtres de tailles trop importantes. En effet, pour un filtre de taille 5x5, et un nombre de filtres égal à 32 au sein d’une unique couche de convolution, il y a 5x5x32 paramètres à calculer, soit 800 paramètres. Sur le réseau tout entier, cela fait plus de 10 000 paramètres à calculer à chaque itération. Il devient presque donc impossible pour nos machines de les faire tourner sur des bases de données comprenant plus de 3 catégories (donc plus de 2000 images). D’autant plus que si l’on augmente la résolution de l’image, les calculs seront d’autant plus longs.</p>
    <p class="has-line-data" data-line-start="246" data-line-end="248">Nous constatons que les résultats des différentes simulations ne suivent pas de logique claire : selon le nombre de classe, des filtres de taille 3x3 peuvent être plus ou moins pertinents.<br>
    Nous choisirons par la suite le meilleur modèle selon que l’on veut trouver sur trois classes (taille : 7x7), six classes (taille 3x3) ou 10 classes (taille 3x3).</p>
    <p class="has-line-data" data-line-start="249" data-line-end="250">Les graphes sont visualisables dans le rapport.</p>
    <h4 class="code-line" data-line-start=251 data-line-end=252 ><a id="Taille_de_limage_251"></a>Taille de l’image</h4>
    <p class="has-line-data" data-line-start="253" data-line-end="254">La résolution de l’image va influencer les résultats attendus. On peut par exemple se convaincre qu’un modèle différenciera mieux des images de bonne qualité que des images de mauvaise qualité, où il un nuage de point et un diagramme en ligne peuvent être peu différenciables.</p>
    <p class="has-line-data" data-line-start="255" data-line-end="256">Le test effectué avec le premier réseau montre qu’une résolution de 64x64 donne de meilleurs résultats. Cela se retrouve pour tous les réseaux, et pour les filtres de taille 3x3 et 5x5. Cependant, il faut noter que, pour certains réseaux avec certains paramètres, on peut trouver  de plus mauvais résultats avec une résolution de 128x128 qu’avec une résolution de 64x64.</p>
    <h4 class="code-line" data-line-start=258 data-line-end=259 ><a id="Influence_du_rseau_258"></a>Influence du réseau</h4>
    <p class="has-line-data" data-line-start="260" data-line-end="261">Nous avons construit plusieurs réseaux pour essayer de comprendre l’influence du réseau sur les résultats. L’architecture des différents réseaux est détaillée dans la partie précédente.</p>
    <p class="has-line-data" data-line-start="262" data-line-end="263">Nous constatons que les résultats dépendent encore une fois du nombre de classes.</p>
    <p class="has-line-data" data-line-start="264" data-line-end="265">Pour conclure, il est compliqué de prédire quel réseau et quels paramètres seront le mieux, avant de les tester sur les bases de données. De manière empirique, nous choisissons donc les modèles suivants :</p>
    <table class="table table-striped table-bordered">
    <thead>
    <tr>
    <th></th>
    <th style="text-align:center">3 classes</th>
    <th style="text-align:center">6 classes</th>
    <th style="text-align:center">10 classes</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>reseau</td>
    <td style="text-align:center">1</td>
    <td style="text-align:center">3</td>
    <td style="text-align:center">1</td>
    </tr>
    <tr>
    <td>filter_size</td>
    <td style="text-align:center">7</td>
    <td style="text-align:center">3</td>
    <td style="text-align:center">3</td>
    </tr>
    <tr>
    <td>size (image)</td>
    <td style="text-align:center">64</td>
    <td style="text-align:center">64</td>
    <td style="text-align:center">64</td>
    </tr>
    <tr>
    <td>learning_rate</td>
    <td style="text-align:center">0.001</td>
    <td style="text-align:center">0.001</td>
    <td style="text-align:center">0.001</td>
    </tr>
    <tr>
    <td>nb_epoch</td>
    <td style="text-align:center">125</td>
    <td style="text-align:center">125</td>
    <td style="text-align:center">125</td>
    </tr>
    <tr>
    <td>Accuracy</td>
    <td style="text-align:center">91.60%</td>
    <td style="text-align:center">81.60%</td>
    <td style="text-align:center">71.03%</td>
    </tr>
    </tbody>
    </table>
    <p class="has-line-data" data-line-start="278" data-line-end="279">Bien entendu, pour généraliser le modèle, nous pouvons garder que le modèle à 10 classes, mais la précision sera plus faible. Si l’on est certain d’avoir un visuel de datavisualization dans les modèles à six classes ou trois classes, nous pourrons utiliser les modèles restreints qui apportent de meilleures performances.</p>
    <h2 class="code-line" data-line-start=280 data-line-end=281 ><a id="Test_dune_image_280"></a>Test d’une image</h2>
    <h3 class="code-line" data-line-start=282 data-line-end=283 ><a id="Visualisation_des_diffrents_scores__graphique_radar_282"></a>Visualisation des différents scores : graphique radar</h3>
    <p class="has-line-data" data-line-start="284" data-line-end="285">Lorsqu’ un modèle entrainé est testé sur le dossier d’images test, l’ensemble des résultats et des paramètres de configuration du modèle sont sauvegardés automatiquement dans un fichier JSON, notamment les prédictions pour chaque image d’appartenir à telle ou telle classe. Ceci permet de garder une trace de nos expérimentations et de traiter ces fichiers JSON afin de représenter les résultats des expériences de manière plus intuitive.</p>
    <p class="has-line-data" data-line-start="286" data-line-end="287">Ainsi, à l’aide du framework D3.js, conçu pour faciliter la représentation de données sous des formats plus lisibles et exploitables analytiquement, nous avons opté pour la représentation Radar afin d’observer la distribution de probabilités pour chaque image test et voir si des tendances se dégageaient.</p>
    <h3 class="code-line" data-line-start=288 data-line-end=289 ><a id="Utilisation_de_lAPI_pour_un_affichage_des_rsultats_288"></a>Utilisation de l’API pour un affichage des résultats</h3>
    <h2 class="code-line" data-line-start=290 data-line-end=291 ><a id="Perspectives_290"></a>Perspectives</h2>
    <p class="has-line-data" data-line-start="292" data-line-end="294">Afin d’explorer les possibilités offertes par les réseaux de neurones convolutionnels, nous avons mis en place cinq réseaux aux structures différentes. Les règles d’architecture d’un réseau de neurones ne sont pas précisément définies mais ils existent des bonnes pratiques qui nous ont guidées lors de la mise en place de nos réseaux.<br>
    Si l’on peut penser que les performances d’un réseau par rapport à un autre sont difficiles à prévoir, ce projet nous l’a confirmé puisque nos résultats nous montrent qu’en fonction des caractéristiques des bases de données (taille des images, nombre de catégories…) le réseau le plus performant et les paramètres associés varient.</p>
    <p class="has-line-data" data-line-start="295" data-line-end="296">Cependant, nos résultats restent à nuancer pour deux raisons principales : notre base de données contenant moins de 500 images pour chacune des catégories, cela peut ne pas être suffisant pour permettre aux réseaux d’apprendre de façon suffisamment abstraite (la base de données MNIST comporte 7 000 images par catégorie !). De plus la puissance limitée de nos ordinateurs personnels nous a obligé à réduire la taille des filtres, ou la résolution des images et ainsi perdre des informations.</p>
    <p class="has-line-data" data-line-start="297" data-line-end="298">Les pistes d’amélioration sont alors les suivantes :</p>
    <ul>
    <li class="has-line-data" data-line-start="298" data-line-end="299">agrandissement considérable de la base de données</li>
    <li class="has-line-data" data-line-start="299" data-line-end="300">augmentation du nombre de catégories</li>
    <li class="has-line-data" data-line-start="300" data-line-end="301">amélioration du site : possibilité de choisir plusieurs réseau entraîné, possibilité de classer un dossier d’image à la place d’une image</li>
    <li class="has-line-data" data-line-start="301" data-line-end="302">construction d’une base de données fournies et labelisées d’images de classification</li>
    <li class="has-line-data" data-line-start="302" data-line-end="303">publication des résultats</li>
    </ul>
    <h2 class="code-line" data-line-start=305 data-line-end=306 ><a id="Auteurs_305"></a>Auteurs</h2>
    <p class="has-line-data" data-line-start="307" data-line-end="312">Arnal Marc<br>
    Brugière Arnaud<br>
    Guery Luca<br>
    Kraemer Louis<br>
    Martin-Delahaye Alexis</p>

                                </div>
                            </section><!--//doc-section-->
                            </div><!--//content-holder-inner-->
                        </div><!--//content-holder-->
                    </div><!--//row-->
                </div><!--//promo-block-inner-->
            </div><!--//container-->
        </div><!--//promo-block-->

    </div><!--//page-wrapper-->

    <footer class="footer text-center">
        <div class="container">
            <!--/* This template is released under the Creative Commons Attribution 3.0 License. Please keep the attribution link below when using for your own project. Thank you for your support. :) If you'd like to use the template without the attribution, you can buy the commercial license via our website: themes.3rdwavemedia.com */-->
            <small class="copyright">Designed by Marc Arnal</small>

        </div><!--//container-->
    </footer><!--//footer-->


    <!-- Main Javascript -->
    <script type="text/javascript" src="assets/plugins/jquery-3.3.1.min.js"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="assets/plugins/prism/prism.js"></script>
    <script type="text/javascript" src="assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js"></script>
    <script type="text/javascript" src="assets/plugins/stickyfill/dist/stickyfill.min.js"></script>
    <script type="text/javascript" src="assets/js/main.js"></script>

</body>
</html>
